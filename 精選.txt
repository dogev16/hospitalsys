@group_required("PHARMACY")
def pharmacy_panel(request):
    today = timezone.localdate()

    prescriptions = (
        Prescription.objects
        .filter(
            date=today,
            status=Prescription.STATUS_FINAL,
            pharmacy_status=Prescription.PHARMACY_PENDING,
            verify_status=Prescription.VERIFY_APPROVED,
        )
        .select_related("patient", "doctor__user")
        .prefetch_related("items__drug")
        .order_by("date", "id")
    )

    MIN_VALID_DAYS = 7

    rx_rows = []
    for rx in prescriptions:
        items = list(rx.items.all())
        problems = []

        for it in items:
            res = can_dispense_item(it, min_valid_days=MIN_VALID_DAYS)

            # ✅ can_dispense_item 可能回 (ok, reason) 或 (ok, reason, extra...)
            if isinstance(res, (tuple, list)):
                ok = bool(res[0]) if len(res) >= 1 else False
                reason = str(res[1]) if len(res) >= 2 else ""
            else:
                # ✅ 若有人不小心讓它回 bool / str，也不炸
                ok = bool(res)
                reason = ""

            if not ok:
                problems.append(reason or f"{it.drug.name} 無法領藥（原因未知）")

        rx_rows.append({
            "rx": rx,
            "can_dispense": (len(problems) == 0),
            "problems": problems,
        })

    return render(request, "prescriptions/pharmacy_panel.html", {
        "today": today,
        "rx_rows": rx_rows,
        "min_valid_days": MIN_VALID_DAYS,
    })
這個 view 負責顯示今天可領藥的處方，
只顯示已完成醫師開立、且通過藥師審核的處方，
並在顯示前先計算每張處方是否可領藥，
避免藥師進入頁面後才發現庫存或效期不足。

@group_required("PHARMACY")
@transaction.atomic
def dispense(request, pk):
    """
    藥局領藥頁面 + 領藥動作

    - GET：顯示處方明細、庫存狀態、按鈕
    - POST：完成領藥（扣庫存、寫異動、更新處方狀態）
    """
    prescription = get_object_or_404(
        Prescription.objects
        .select_related("patient", "doctor__user")
        .prefetch_related("items__drug"),
        pk=pk,
    )

    # 1️⃣ 審核狀態檢查：沒通過就不能領藥
    if prescription.verify_status != Prescription.VERIFY_APPROVED:
        messages.error(request, "此處方尚未通過藥師審核，不能領藥 。")
        return redirect("prescriptions:pharmacy_panel")

    # 2️⃣ 藥局狀態檢查：已作廢 / 已退藥 不可領
    if prescription.pharmacy_status == Prescription.PHARMACY_CANCELLED:
        messages.error(request, "此處方已作廢或退藥，不能再領藥 。")
        return redirect("prescriptions:pharmacy_panel")

    # 3️⃣ 已領藥不可重複領
    if prescription.pharmacy_status == Prescription.PHARMACY_DONE:
        messages.warning(request, "此處方已完成領藥，無需再次操作 。")
        return redirect("prescriptions:pharmacy_panel")

    # 先把 items 抓出來，GET / POST 都會用到
    items = list(prescription.items.all())

    # 計算是否有任何一項庫存不足（給 GET 畫面用）
    has_shortage = any(
        item.drug.stock_quantity < item.quantity
        for item in items
    )

    if request.method == "POST":
        action = request.POST.get("action", "complete")

        # 目前我們只處理完成領藥這個動作
        if action == "complete":
            # 再檢查一次庫存（避免有人趁你打開畫面時別處改了庫存）
            insufficient = []
            for item in items:
                drug = item.drug
                if drug.stock_quantity < item.quantity:
                    insufficient.append((drug, drug.stock_quantity, item.quantity))

            if insufficient:
                # 組錯誤訊息
                msg_lines = []
                for drug, stock, need in insufficient:
                    msg_lines.append(f"{drug.name} 庫存不足（現有 {stock}，需要 {need}）")
                messages.error(request, "無法完成領藥 ：\n" + "\n".join(msg_lines))
                return redirect("prescriptions:pharmacy_panel")

            # 2️⃣ 扣庫存 + 寫異動紀錄（使用 utils 工具函式）
            for item in items:
                use_drug_from_prescription_item(
                    item,
                    prescription=prescription,
                    operator=request.user,
                )

            # 3️⃣ 更新處方的藥局狀態 & 領藥資訊
            prescription.pharmacy_status = Prescription.PHARMACY_DONE
            prescription.dispensed_at = timezone.now()
            prescription.dispensed_by = request.user  # 領藥藥師

            # 保險：醫師端狀態也設成 FINAL
            if prescription.status != Prescription.STATUS_FINAL:
                prescription.status = Prescription.STATUS_FINAL

            prescription.save()

            # 4️⃣ 寫入處方異動紀錄
            add_prescription_log(
                prescription,
                PrescriptionLog.ACTION_DISPENSE,
                "藥局完成領藥並扣庫存",
                user=request.user,
            )

            # 5️⃣ 寫入 audit log（技術向紀錄）
            PrescriptionAuditLog.objects.create(
                prescription=prescription,
                action="DISPENSE",
                performed_by=request.user,
                detail="藥局完成領藥並扣庫存",
            )

            messages.success(request, f"處方 #{prescription.id} 已完成領藥 ！")
            return redirect("prescriptions:pharmacy_panel")

        # 未來如果有其他 action（例如部分退藥），可以在這裡加 elif

        messages.error(request, "未知的動作 ，請再試一次。")
        return redirect("prescriptions:pharmacy_panel")

    # GET：顯示領藥畫面
    context = {
        "prescription": prescription,
        "items": items,
        "has_shortage": has_shortage,
    }
    return render(request, "prescriptions/pharmacy_dispense.html", context)

在完成領藥時，我設計了多層檢查，
包含審核狀態、是否已領藥、以及即時庫存確認，
並使用 transaction 確保扣庫存與狀態更新為同一個原子操作，
避免重複發藥或資料不一致。

    @group_required("PHARMACY")
def pharmacy_review_list(request):
    """
    藥師審核列表：顯示今天所有『待審核』的處方
    """
    today = timezone.localdate()

    prescriptions = (
        Prescription.objects
        .filter(
            date=today,
            status=Prescription.STATUS_FINAL,
            verify_status=Prescription.VERIFY_PENDING,  # 只抓待審核
        )
        .select_related("patient", "doctor__user")
        .prefetch_related("items__drug")
        .order_by("date", "id")
    )

    context = {
        "prescriptions": prescriptions,
        "today": today,
    }
    return render(request, "prescriptions/pharmacy_review_list.html", context)


@group_required("PHARMACY")
@transaction.atomic
def pharmacy_review_detail(request, pk):
    """
    藥師審核單一處方：
    - GET：顯示處方內容
    - POST：approve / reject
    """
    prescription = get_object_or_404(
        Prescription.objects
        .select_related("patient", "doctor__user")
        .prefetch_related("items__drug"),
        pk=pk,
    )

    # 只有正式處方才可以審
    if prescription.status != Prescription.STATUS_FINAL:
        messages.error(request, "此處方尚未完成，無法審核 。")
        return redirect("prescriptions:pharmacy_review_list")

    if request.method == "POST":
        action = request.POST.get("action")
        note = (request.POST.get("verify_note") or "").strip()

        if action == "approve":
            # 1️⃣ 更新處方審核欄位
            prescription.verify_status = Prescription.VERIFY_APPROVED
            prescription.verified_by = request.user
            prescription.verified_at = timezone.now()
            prescription.verify_note = note
            prescription.save(update_fields=[
                "verify_status",
                "verified_by",
                "verified_at",
                "verify_note",
            ])

            # 2️⃣ 寫入簡要異動紀錄（給醫師 / 藥師看 timeline 用）
            msg = "藥師審核通過"
            if note:
                msg += f"（備註：{note}）"
            add_prescription_log(
                prescription,
                PrescriptionLog.ACTION_UPDATE,
                msg,
                user=request.user,
            )

            # 3️⃣ 寫入 audit log（給系統/老師看比較技術向的紀錄）
            PrescriptionAuditLog.objects.create(
                prescription=prescription,
                action="UPDATE",
                performed_by=request.user,
                detail=f"藥師審核通過。verify_status=approved；note={note}",
            )

            messages.success(request, f"處方 #{prescription.id} 已通過審核 ！")
            return redirect("prescriptions:pharmacy_review_list")

        elif action == "reject":
            # 1️⃣ 更新處方審核欄位
            prescription.verify_status = Prescription.VERIFY_REJECTED
            prescription.verified_by = request.user
            prescription.verified_at = timezone.now()
            prescription.verify_note = note or "處方需醫師修正"
            prescription.save(update_fields=[
                "verify_status",
                "verified_by",
                "verified_at",
                "verify_note",
            ])

            # 2️⃣ 寫入簡要異動紀錄
            add_prescription_log(
                prescription,
                PrescriptionLog.ACTION_UPDATE,
                f"藥師退回處方。原因：{prescription.verify_note}",
                user=request.user,
            )

            # 3️⃣ 寫入 audit log
            PrescriptionAuditLog.objects.create(
                prescription=prescription,
                action="UPDATE",
                performed_by=request.user,
                detail=f"藥師退回處方。verify_status=rejected；note={prescription.verify_note}",
            )

            messages.warning(request, f"處方 #{prescription.id} 已退回醫師 。")
            return redirect("prescriptions:pharmacy_review_list")
        else:
            messages.error(request, "未知的審核動作 ，請再試一次。")
            return redirect("prescriptions:pharmacy_review_list")

    # ⭐ 這裡補上 logs / audit_logs，給 GET 畫面使用
    logs = (
        PrescriptionLog.objects
        .filter(prescription=prescription)
        .select_related("operator")
        .order_by("-created_at")
    )
    audit_logs = (
        PrescriptionAuditLog.objects
        .filter(prescription=prescription)
        .select_related("performed_by")
        .order_by("-created_at")
    )

    context = {
        "prescription": prescription,
        "logs": logs,
        "audit_logs": audit_logs,
    }
    return render(request, "prescriptions/pharmacy_review_detail.html", context)

我將藥師審核與實際發藥分成兩個階段，
確保處方內容在進入藥局流程前已被確認，
同時保留完整審核紀錄與備註，方便追蹤。

@group_required("DOCTOR")
def edit_for_ticket(request, ticket_id):
    """
    醫師針對某一張掛號票 (VisitTicket) 開 / 編輯處方
    URL 範例：/prescriptions/ticket/11/
    """
    print("=== [DEBUG] edit_for_ticket 進來了 ，method =", request.method)

    ticket = get_object_or_404(VisitTicket, id=ticket_id)

    # 確保登入的醫師就是這張 ticket 的醫師
    doctor = get_object_or_404(Doctor, user=request.user)
    if ticket.doctor != doctor:
        messages.error(request, "你不是這張掛號票的醫師 ，不能開處方。")
        return redirect("queues:doctor_panel")

    # 以掛號（VisitTicket）為唯一依據，找或建立處方
    prescription, created = Prescription.objects.get_or_create(
        visit_ticket=ticket,
        defaults={
            "patient": ticket.patient,
            "doctor": ticket.doctor,
            "date": ticket.date,   # 或 ticket.created_at.date() 視你 model 的欄位而定
            "status": Prescription.STATUS_DRAFT,
        },
    )

    if request.method == "POST":
        print("=== [DEBUG] 收到 POST 了 ！POST 內容：", request.POST)

        form = PrescriptionForm(request.POST, instance=prescription)
        items = PrescriptionItemFormSet(request.POST, instance=prescription)

        print("=== [DEBUG] form.is_valid():", form.is_valid())
        print("=== [DEBUG] form.errors:", form.errors)
        print("=== [DEBUG] items.is_valid():", items.is_valid())
        print("=== [DEBUG] items.errors:", items.errors)
        print("=== [DEBUG] items.non_form_errors():", items.non_form_errors())

        if form.is_valid() and items.is_valid():
            # 先存主檔
            prescription = form.save(commit=False)
            prescription.patient = ticket.patient
            prescription.doctor = ticket.doctor
            prescription.date = ticket.date

            # 醫師送出 → 正式處方 + 重設審核狀態為「待審核」
            prescription.status = Prescription.STATUS_FINAL
            prescription.verify_status = Prescription.VERIFY_PENDING
            prescription.verified_by = None
            prescription.verified_at = None
            prescription.verify_note = ""

            prescription.save()

            # 再存明細
            items.instance = prescription
            items.save()

            # ⭐ 寫入異動紀錄
            add_prescription_log(
                prescription,
                PrescriptionLog.ACTION_UPDATE,
                "醫師儲存處方內容",
                user=request.user,
            )

            print("=== [DEBUG] 處方已成功儲存 ，準備 redirect ===")
            messages.success(request, "處方已儲存 ！")
            return redirect("queues:doctor_panel")
        else:
            print("=== [DEBUG] 表單驗證沒過 ，會回到同一頁並顯示錯誤 ===")
            messages.error(request, "表單有錯誤 ，請檢查紅色欄位。")

    else:
        # GET：第一次進來畫面
        form = PrescriptionForm(instance=prescription)
        items = PrescriptionItemFormSet(instance=prescription)

    context = {
        "ticket": ticket,
        "prescription": prescription,
        "form": form,
        "items": items,
        "patient": ticket.patient,
    }
    return render(request, "prescriptions/prescription_form.html", context)

醫師是以掛號票為單位開立處方，
確保每張處方都對應實際看診紀錄，
避免出現沒有看診卻有處方的情況。

@group_required("PHARMACY")
@transaction.atomic
def cancel_or_return_prescription(request, pk):
    prescription = get_object_or_404(
        Prescription.objects.prefetch_related("items__drug"),
        pk=pk
    )

    # 不能對已作廢的處方做動作
    if prescription.pharmacy_status == Prescription.PHARMACY_CANCELLED:
        messages.warning(request, "這張處方已經作廢過 。")
        return redirect("prescriptions:pharmacy_panel")

    # POST 才能操作
    if request.method == "POST":

        # 1️⃣ 情境一：還沒領藥 → 作廢（不動庫存）
        if prescription.pharmacy_status == Prescription.PHARMACY_PENDING:
            prescription.pharmacy_status = Prescription.PHARMACY_CANCELLED
            prescription.save()

            # ⭐ 異動紀錄：作廢
            add_prescription_log(
                prescription,
                PrescriptionLog.ACTION_CANCEL,
                "處方尚未領藥，藥局作廢處方",
                user=request.user,
            )

            # ⭐ audit log
            PrescriptionAuditLog.objects.create(
                prescription=prescription,
                action="CANCEL",
                performed_by=request.user,
                detail="處方尚未領藥，藥局作廢處方（不動庫存）",
            )

            messages.success(request, f"處方 #{prescription.id} 已作廢 ！")
            return redirect("prescriptions:pharmacy_panel")

        # 2️⃣ 情境二：已領藥 → 退藥（加回庫存）
        if prescription.pharmacy_status == Prescription.PHARMACY_DONE:

            for item in prescription.items.all():
                # 使用通用庫存調整工具，把每個藥加回去
                adjust_stock(
                    drug=item.drug,
                    change=+item.quantity,   # 正數＝加回庫存
                    reason="return",
                    note=f"處方 #{prescription.id} 退藥",
                    prescription=prescription,
                    operator=request.user,
                )

            prescription.pharmacy_status = Prescription.PHARMACY_CANCELLED
            prescription.save()

            # ⭐ 異動紀錄：退藥＋作廢
            add_prescription_log(
                prescription,
                PrescriptionLog.ACTION_RETURN,
                "已發藥，藥局退藥並作廢處方，庫存加回",
                user=request.user,
            )

            # ⭐ audit log
            PrescriptionAuditLog.objects.create(
                prescription=prescription,
                action="RETURN",
                performed_by=request.user,
                detail="已發藥，藥局退藥並作廢處方，庫存加回",
            )

            messages.success(request, f"處方 #{prescription.id} 已退藥並作廢 ！")
            return redirect("prescriptions:pharmacy_panel")

    # GET → 顯示一個簡單確認畫面（你可自己做）
    return render(request, "prescriptions/cancel_or_return_confirm.html", {
        "prescription": prescription,
    })

我有區分「尚未領藥作廢」與「已領藥退藥」兩種情境，
並依狀態決定是否需要回補庫存，
確保庫存數量與實際狀態一致。

以上全部是來自"C:\project\hospitalsys\prescriptions\views.py"

@transaction.atomic
def adjust_stock(
    drug: Drug,
    change: int,
    reason: str,
    note: str = "",
    prescription=None,
    operator=None,
):
    """
    舊版「以 Drug.stock_quantity 為主」的調整工具。
    為了相容保留；批次模式下你應該改用 adjust_batch_stock  
    """
    new_stock = (drug.stock_quantity or 0) + change
    if new_stock < 0:
        raise ValueError(f"{drug.name} 庫存不足，無法扣除 {abs(change)}  ")

    drug.stock_quantity = new_stock
    drug.save(update_fields=["stock_quantity"])

    StockTransaction.objects.create(
        drug=drug,
        batch=None,
        change=change,
        reason=reason,
        note=note,
        prescription=prescription,
        operator=operator,
    )
    return drug

所有庫存變動都集中透過 adjust_stock 處理，
避免在不同地方直接修改庫存數量，
讓庫存邏輯集中、可追蹤、可審計。

@group_required("PHARMACY")
@transaction.atomic
def stock_adjust(request, pk):
    """
    單一藥品庫存調整：
    - 使用 StockAdjustForm 收集「原因 / 數量 / 備註」
    - 實際異動交給 inventory.utils.adjust_stock()
    """
    drug = get_object_or_404(Drug, pk=pk)

    if request.method == "POST":
        form = StockAdjustForm(request.POST)
        if form.is_valid():
            reason = form.cleaned_data["reason"]   # purchase / dispense / return / adjust
            qty = form.cleaned_data["quantity"]    # 正整數
            note = form.cleaned_data["note"]

            # 依照原因決定是加還是減
            change = qty
            if reason in ("dispense", "adjust") and qty > 0:
                # 發藥或調整（扣庫存）：變成負數
                change = -qty

            try:
                # ✨ 統一透過 adjust_stock 處理：
                # - 檢查庫存是否不足
                # - 寫入 StockTransaction
                # - 更新 drug.stock_quantity
                adjust_stock(
                    drug=drug,
                    change=change,
                    reason=reason,
                    note=note,
                    prescription=None,
                    operator=request.user,   # ✅ 記錄調整人
                )
            except ValueError as e:
                # 例如：庫存不足會在 adjust_stock 丟 ValueError
                messages.error(request, str(e))
            else:
                # 重新讀取最新庫存
                drug.refresh_from_db()
                messages.success(
                    request,
                    f"已調整 {drug.name} 庫存（變動 {change}，目前庫存 {drug.stock_quantity}） ",
                )
                return redirect("inventory:drug_list")
        else:
            # 先印出錯誤，方便你看 console 除錯
            print("StockAdjustForm errors:", form.errors)
    else:
        form = StockAdjustForm()

    # 最近 20 筆該藥品的異動紀錄
    logs = (
        StockTransaction.objects.filter(drug=drug)
        .order_by("-created_at")[:20]
    )

    return render(
        request,
        "inventory/stock_adjust.html",
        {
            "drug": drug,
            "form": form,
            "logs": logs,
        },
    )

提供藥師手動調整庫存的入口，
每次調整都必須指定原因與備註，
並寫入異動紀錄，避免黑箱操作。

@group_required("PHARMACY")
def expiry_dashboard(request):
    """
    藥品效期管理儀表板：
    - 已過期（不可發藥）
    - N 天內到期（提醒）
    - 隔離批次（不可發藥，待藥師處理）
    """
    today = timezone.localdate()
    warning_days = 30
    warn_date = today + timedelta(days=warning_days)

    expired_batches = (
        StockBatch.objects
        .select_related("drug")
        .filter(
            status=StockBatch.STATUS_NORMAL,
            expiry_date__lt=today,
            quantity__gt=0,
        )
        .order_by("expiry_date", "drug__name", "batch_no")
    )

    near_expiry_batches = (
        StockBatch.objects
        .select_related("drug")
        .filter(
            status=StockBatch.STATUS_NORMAL,
            expiry_date__gte=today,
            expiry_date__lte=warn_date,
            quantity__gt=0,
        )
        .order_by("expiry_date", "drug__name", "batch_no")
    )

    quarantined_batches = (
        StockBatch.objects
        .select_related("drug")
        .filter(
            status=StockBatch.STATUS_QUARANTINE,
            quantity__gt=0,
        )
        .order_by("expiry_date", "drug__name", "batch_no")
    )

    q = (request.GET.get("q") or "").strip()
    search_batches = StockBatch.objects.none()
    if q:
        search_batches = (
            StockBatch.objects
            .select_related("drug")
            .filter(quantity__gt=0)
            .filter(
                Q(drug__code__icontains=q) |
                Q(drug__name__icontains=q) |
                Q(batch_no__icontains=q)
            )
            .order_by("expiry_date", "id")[:50]
        )

    expired_count = expired_batches.count()
    near_expiry_count = near_expiry_batches.count()
    quarantine_count = quarantined_batches.count()
    
我有將庫存拆分成批次與效期管理，
過期或隔離批次無法被發藥，
確保病人只會拿到有效藥品。